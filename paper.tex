\documentclass[10pt,a4paper,draft]{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\author{Brendan Benshoof}
\title{Overview of Parallel Convex Hull Algorithms}
\begin{document}
\maketitle{}


\section{Introduction}

The Convex Hull problem can be considered one of the most well studied problems in computational geometry. There are numerous centralized algorithms and an achievable lower bound of O(nlog(n)) time (the sorting bound). It is surprising that there are a comparatively smaller number of parallel algorithms that have been researched.
Two major approaches (Divide and Conquer vs. Sampling) and three major algorithms (Atallah's algorithm\cite{Atallah1986Efficient}, qHull, and High Confidence sampling) dominate literature on the topic.
 

\subsection{Problem Formulation}

A convex hull, is a graph of a subset of a set of points in space such that the convex polytope described by that graph contains all points in the set.

The convex hull problem is involved in many common computations including collision detection and delunay-triangulation/voronoi tessellation.


\section{Overview of Literature}

Literature can be divided into two strong groupings. Those that derive from a high-probability of accuracy sampling method and those papers who's algorithm derives from divide and conquer approach.

The papers concerning divide and conquer approaches can be divided further into the papers that implement the parallel convex hull algorithm for EREW PRAM presented by Atallah et al versus the more modern algorithm which derive from the quick hull algorithm presented by Barber et al.


\section{Divide and Conquer methods}

Divide and Conquer is one of the basic computer science problem solving techniques. It's basis is in find a method to reduce a problem to simpler sub-problems then merge those sub-problems into a global solution. Breaking the global problem into sub-problems makes it well adapted to application in parallel algorithms, where each sub-problem can be solved in parallel, with most time being consumed by merging the sub-problems.


\subsection{Properties and applications}

Most papers discussed in this section derive from a divide and conquer method presented by Atallah et al.
This algorithm is only defined for planar convex hull.

In practice, on GPU implementations, modern algorithms for convex hull calculation are based on the quick hull algorithm presented by Barber et .
\subsection{Overview of literature}
Here I overview the papers I have categorized as Divide and Conquer approaches to parallel convex hull. They are presented in approximate order of development and publication. I present a summary of the contribution of the paper and a discussion of how it effected later work.
\subsubsection{Atallah et al}
Atallah et al present a parallel variation of traditional divide and conquer algorithms for $O(n)$ processors. They present an $O(\log(n))$ time algorithm given $O(n)$ processors. Rather than splitting the problem space in an iterative binary fashion, they subdivide the problem space into $O(\sqrt{n})$ subdivisions. This allows the sub-problems each to be processed in parallel by $O(\sqrt{n})$ processors. This allows each sub-problem to be viewed independently as a problem with $O(n)$ input and $O(n)$ processors and this method can be applied recursively until trivial problems are established.

This elegant dividing of the problem space hinges on even subdivision of work. In the case of parallel convex hull, points are sorted along any convent axis using $O(\log(n))$ time (which dominates run-time).
Then $O(\sqrt{n})$ contiguous portions of $O(\sqrt{n})$ points are recursively solved and merged.

When recursively subdividing the space, while the ratio between bits of input and number of processors is $O(1)$ it is realistic to assume that data points outnumber the processors by more than three to one.
Thus, is subdivision reaches three or less points in a group, it can cease further subdivision as sets of points three or less have a trivial convex hull.
More realistically, once the subdivision cannot continue due to lack of processors, the convex hull of the $O(1)$ remaining points can be solved by a single processor in constant time using any one of the established sequential methods.
If all data has been provided initially to all nodes, the subdivision step can be preformed in $O(\log(n))$ time.


The bulk of computation is contained in the merging step. The recursive division step has created a merge tree, requiring $O(\log(n))$ iterations of the merging algorithm.
Once the points have been separated into trivial sub-problems they are merged in parallel in constant time. $O(\sqrt(n))$ subsets are merged using $O(n)$ processors, therefore we can assign one processor to each pair of potential merges.

%% How does merging actually happen in constant time per level

Atallah et al's algorithm is applied to more specific parallel computing architectures in later papers.

\subsubsection{Diallo et al}


\subsubsection{Miller et al}

\subsection{qhull derived methods}
\subsubsection{Barber et al}
Barber et al does not present a parallel algorithm. It is included in this survey as it presents the QuickHull algorithm which other papers present a parallel variation of for GPU computing.

QuickHull's approach is to grow a area/volume which aggressively discards points and divides the remaining points into smaller sub-problems along the faces of the area's growth.
Barber et al presents QuickHull as a solution to 2d convex hull, however unlike many other sequential convex hull algorithms it is extended trivially into higher dimensions.
Like many other sequential convex hull algorithms, it requires $O(n\log(n))$ time (the sorting lower bound).


\subsubsection{Day}
\subsubsection{Srungarapu et al}
\subsubsection{Stein et al}



\subsubsection{Amato et al}



\section{Sampling Methods}


\subsection{Properties and applications}
Sampling methods are generally not searching for solutions in a geometrically inutitive way.
They pose the convex hull problem as a linear programming problem and utilize conventional parallel search methods to generate a high confidance set of points as members of the convex hull.
This presents the problem, that while finding the set of points in a convex hull is a more computationally simple task than finding the entire hull, most applications require a full description of bother the verticies and edges of the convex hull polytope.
\subsection{Overview of literature}


\subsubsection{Dehne et al}
It is worth noting that this work shares coauthor with Atallah et al in Michael Goodrich.
This work presents 


\subsubsection{Ghouse et al}

\bibliography{cites}
	\bibliographystyle{plain}

\end{document}